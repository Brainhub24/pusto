Python. Подкоманды в argparse
-----------------------------
..
  - введение
  - неудобный интерфейс subcommands
  - надстройки типа argh
  - любимый метод
  - выводы

В моей практике почти в каждом проекте есть интерфейс для командной строки, это может быть
``manage.py`` в веб проекте, просто скрипт бекапа или даже приложение GTK. В python 2.7 и 
3.2 появился модуль argparse__ для обработки параметров командной строки. Этот модуль
очень мощный, а самое главное в нем есть из коробки поддержка подкоманд и это очень круто. 
Но есть в этом модуле маленький недостаток - интерфейс его использования немного 
избыточен. Про улучшение использования argparse в повседневной жизни хочу и поговорить.

__ http://docs.python.org/2.7/library/argparse.html

.. MORE

Для начала нужно глянуть что уж такого плохого в интерфейсе, для этого рассмотрим простой
пример:

.. include:: example.py
   :code: py

Вроде не так уж все и плохо, обычный интерфейс. Есть дублирование параметра 
``--settings``, но чтоб он был привязан к каждой подкоманде его нельзя вешать на базовый 
парсер. Также нам пришлось переносить строки для соблюдения :PEP:`8`, при том что не 
помещались считанные символы. Можно укоротить переменные ``cmd_run``, ``cmd_test`` до 
``run``, ``test`` или даже до ``r``, ``t``, но суть не в этом. Эти переменные в принципе 
не нужны, если добавить цепочки вызовов:

.. code:: py

    cmds.add_parser('run').add_argument('port').set_defaults(func=run_server)

На чистом argparse цепочек вызовов не получится, хотя может в каких-то случаях 
использования они не нужны. В моей практике чаще хочется цепочек.

В примере, в самом начале объявлены пара функций и есть проекты, которые превращают эти
функции в подкоманды, типа: opster__, argh__, komandr__. Последние два основаны на
argparse, а opster использует getopt__

__ https://pypi.python.org/pypi/opster
__ https://pypi.python.org/pypi/argh
__ https://pypi.python.org/pypi/komandr
__ http://docs.python.org/2.7/library/getopt.html

В некоторых случаях использование подобных улучшаторов выглядит очень клево, например
использование argh:

.. include:: example-argh.py
    :code: py

Вывод главного help такой же как из первого примера::


    usage: example-argh.py [-h] {run,test,t,te} ...

    positional arguments:
      {run,test,t,te}
        run            run dev server
        test (t, te)   run tests

    optional arguments:
      -h, --help       show this help message and exit

А вот вывод help для определенной подкоманды отличается отсутствием описаний и различием 
коротких аналогов для параметров::

    ===pure argparse===
    usage: app run [-h] [-s SETTINGS] [-P PORT] [-H HOST] [--no-reload]

    optional arguments:
      -h, --help            show this help message and exit
      -s SETTINGS, --settings SETTINGS
                            application settings
      -P PORT, --port PORT  server port
      -H HOST, --host HOST  server host
      --no-reload           without reloading


    ===argh===
    usage: example-argh.py run [-h] [--host HOST] [-p PORT] [-n] [-s SETTINGS]

    run dev server

    optional arguments:
      -h, --help            show this help message and exit
      --host HOST
      -p PORT, --port PORT
      -n, --no-reload
      -s SETTINGS, --settings SETTINGS

В принципе можно добиться полного соответствия help, но от этого уже будет страдать
предельная лаконичность второго примера. Вообще-то если названия параметров не требуют
пояснений, то использовать argh очень заманчиво тем более он в принципе позволяет
добраться до обычного argparse, если где-то сталкиваешься с ограничениями.

Вся прелесть argparse, что с python 2.7 и 3.2 входит в стандартную библиотеку и реально 
крут по сравнению с тем же getopt и optparse__, а перечисленные выше улучшаторы это 
отдельные пакеты и таскать их зависимостями в каждый проект не прикольно, особенно если 
проект минималистичный или небольшой скрипт с подкомандами. Еще в улучшаторах часто 
присутствует немного магии, argparse же прямой как двери.

__ http://docs.python.org/3/library/optparse.html

Хорошо бы использовать argparse, но как-то покрасивее чем в первом примере.

Следующий пример мой любимый способ:

.. include:: example-chain.py
   :code: py

По-моему выходит очень читабильно:
  - обратный слеш в цепочках вызовов мне больше нравиться, хотя перенос строк больше люблю 
    делать внутри скобок;
  - глобальные опции, типа ``--settings``, мы можем определять в одном месте без 
    дублирования;
  - чем больше подкоманд и параметров, тем оправданнее добавление вложенной функции 
    ``cmd``.

Поиспользовав в нескольких местах такой подход, мне все больше нравится отделение 
интерфейса функции от вызовов командной строки, все таки это немного разные вещи. Хотя 
раньше мне очень нравилось превращение функций в подкоманды. Хорошо что это чистый 
argparse, хоть у него интерфейс не сразу запомнишь, зато если чаще его использовать, то 
даже этот интерфейс запомнится.

Вывод довольно банальный, у python очень крутая стандартная библиотека, argparse очень 
мощный инструмент для работы с параметрами командной строки. И даже если есть какие-то 
библиотеки с красивыми плюшками (argh, opster или docopt__) у них скорее всего тоже 
найдутся свои недостатки, поэтому мой выбор подточить использование argparse и забыть про 
дополнительные зависимости.

__ http://docopt.org/
