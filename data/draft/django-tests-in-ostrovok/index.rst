Django tests. Практические советы
=================================
- `habr <habr/>`_
- `ru-pycon-2013 </s/2013-ru-pycon/>`_
- `бда-бла <bla.rst>`_

..
    - введение
    - избегайте static fixtures
    - трюк с settings
    - транзакции наше все
    - cache and redis
    - в несколько процесов (djtest-bootstrap)


С апреля уже не работаю в ostrovok.ru, но опыт полученный в этой команде по внедрению 
тестов в разработку очень хороший. Хочу записать по горячим следам ряд практический 
советов и замечаний по поводу внедрения тестов и django тестов в частности.

.. MORE

В ostrovok.ru мне нужно было возобновить написание тестов. Проект уже жил больше года до 
меня и имел довольно обширную кодовую базу. Внедрять тесты в уже существующий проект с 
кучей всесторонних зависимостей от внешних сервисов и API, задача требующая довольно много 
времени. Плюс возвращаться и дорабатывать их нужно будет не один раз. Хорошо что в 
ostrovok.ru все понимали что тесты нужны, просто не знали с какой стороны к ним подойти и 
нужен был человек, который "заражен" тестами и возьмется за внедрение.

Про первые шаги `писал на хабре (26.06.2013)`, потом позже рассказывал на `Pycon Russia 
(24.02.2013)` про оптимизацию и запуск тестов в несколько процессов. Когда уходил из 
ostrovok.ru тестов было ~1000(6 мин на моем ноутбуке, 4 процесса), через пол года сказали, 
что уже ~1500(6 мин на CI сервере, много процессов). Тесты удались, хотя некоторые места 
хотелось бы сделать лучше.

.. Наверно самый первый совет: пишите тесты с самого начала, если проект будет 
   долгоиграющий, т.е. постоянно дорабатываться и обрастать новыми функциями. Хорошо когда 
   команда сразу формируется из любителей писать тесты, тогда вопроса про внедрения тестов 
   через год существования проекта не возникнет.

Поговорим про некоторые проблемы и способы их не допустить.

Транзакции для изоляции базы
----------------------------
В моем мозгу, изоляция окружения для конкретного теста - это обязательное условие для 
существования хороших тестов. Для изоляции базы самый верный способ - это транзакции, они 
быстрые. В  начале теста мы открываем транзакцию, а после прохождения теста делаем ее 
откат (rollback), ну и условие напрашивается само - не должно быть прерывания открытой 
транзакции. У нас вышло так, что в процессе бронирования было ручное управление 
транзакциями, а тестов вокруг бронирования у нас было очень много (больше всего хотелось 
покрыть тестами именно этот процесс), поэтому мне пришлось придумывать свой механизм 
изоляции базы на основе копирования базы из шаблона. Хотя этот механизм был быстрее 
`стандартного в django для этого случая`, но он был медленее и сложнее транзакций. Поэтому 
когда делался запуск тестов в несколько процессов, пришлось приложить больше усилий, чтоб 
все наши тесты хорошо работали.

**Нужно стараться чтоб в транзакциях работали максимум тестов.** `Транзакции хорошо 
маштабируются на несколько процессов`, а те тесты, в которых все таки нужно протестировать 
именно транзакции, пускать отдельно в одном процессе уже после основной пачки тестов.

Зависимость тестов от фикстур
-----------------------------
Если над проектом постоянно работают, статические фикстуры - зло. Мы старались 
использовать минимум фикстур, но совсем без них не возможно. Все эти сторонние сервисы и 
API требуют моков, а моки за собой тянут фикстуры. У нас статических фикстур было немного, 
были даже скрипты, которые могли их обновлять, но процесс обновления фикстур не был 
встроен в CI, поэтому зависимость тестов от них стала одной из проблем, которую так до 
конца и не решили.

**По-хорошему они должны генерироваться динамически и этот процесс нужно встроить в CI.**
Сторонние сервисы тоже разрабатываются и придет время когда нужно будет обновить фикстуры 
до новой версии, а зависимых тестов может оказаться довольно много, когда в команде пишут 
тесты несколько человек и не все знают про возможные проблемы, а тесты писать нужно... 
Динамические фикстуры или постоянное обновление статических фикстур не препятствуют 
появлению зависимых тестов.

Вообще фикстуры, по моему мнению, одна из самых сложных задач при долгосрочном 
тестировании, т.е. попасться в капкан зависимости от фикстур довольно легко.

Mocks
-----
Опять же в моем мозгу сидит, что все внешние вызовы должны быть "замоканы" для того чтоб 
тесты были предсказуемые и быстрые. Даже самый быстрый и надежный сторонний сервис может 
дать сбой или ответить каким-то не совсем ожидаемым способом и тогда тесты упадут. Но 
тесты не должны падать из-за внешних условий, поэтому мы подменяем действительность моками 
и прописываем те ответы, которые мы ожидаем в тестах. Есть еще ряд случаев, в которых без 
моков не обойтись, это могут быть разные моменты со временем, проверка на прошлое или 
будущее, проверка выпадения исключений и т.п. В общем в проекте с тестами скорее всего 
будут моки, у нас их было много. Хоть мы имеем дело с динамическим языком python и модуль 
`mock` очень помогает нам, но моки - это в своем роде магия и у модуля ``mock`` есть свои 
нюансы и ограничения, про которые не все разработчики знают. Время от времени моки 
становились проблемой, особенно когда их сайд-эффекты сложно было определить. К ним нужно 
привыкнуть, с опытом их использовать и чинить становиться проще.
